{"version":3,"sources":["webpack://backend/webpack/bootstrap","webpack://backend/./backend/src/config/middleware/adapter/io.js","webpack://backend/external \"require3\"","webpack://backend/./backend/src/model/messageClass.js","webpack://backend/./backend/src/model/message.js","webpack://backend/./backend/src/model/messageSync.js","webpack://backend/./backend/src/main.js","webpack://backend/./backend/src/config/config.js","webpack://backend/./backend/src/config/middleware/adapter/socketEmit.js","webpack://backend/./backend/src/config/locales.js","webpack://backend/./backend/src/config/locale/zh-cn.js","webpack://backend/./backend/src/config/errors.js","webpack://backend/./backend/src/config/middlewares.js","webpack://backend/./backend/src/config/middleware/connection.js","webpack://backend/./backend/src/config/middleware/adapter/messageClass.js","webpack://backend/./backend/src/config/middleware/adapter/message.js","webpack://backend/./backend/src/config/sql/procedure.js","webpack://backend/./backend/src/config/middleware/packet.js","webpack://backend/./backend/src/config/middleware/io.js","webpack://backend/./backend/src/routes.js","webpack://backend/./backend/src/controller/version.js","webpack://backend/./backend/src/controller/io.js","webpack://backend/./backend/src/controller/messageClass.js","webpack://backend/./backend/src/controller/message.js","webpack://backend/./backend/src/services.js","webpack://backend/./backend/src/service/version.js","webpack://backend/./backend/src/service/io.js","webpack://backend/./backend/src/service/messageClass.js","webpack://backend/./backend/src/service/message.js","webpack://backend/./backend/src/models.js","webpack://backend/./backend/src/meta.js","webpack://backend/./backend/src/config/validation/schemas.js"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;AClFA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;;AAEA,uBAAuB,mBAAO,CAAC,EAAmB;AAClD,kBAAkB,mBAAO,CAAC,EAAc;;AAExC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB,GAAG,QAAQ,GAAG,KAAK;AAC1D,yBAAyB,sBAAsB,GAAG,SAAS;AAC3D;AACA;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB,GAAG,QAAQ,GAAG,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,sBAAsB;AAC3D;AACA,2BAA2B,UAAU,EAAE,IAAI,GAAG,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,wCAAwC;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,oBAAoB;AACnE,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,uCAAuC;AAC/D;AACA;AACA;AACA;AACA;AACA,oEAAoE,wCAAwC;AAC5G;AACA;AACA;AACA,oDAAoD,kEAAkE;AACtH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA,6BAA6B,+CAA+C;AAC5E;AACA;;AAEA;AACA,yBAAyB,qDAAqD;AAC9E;AACA;AACA;AACA;AACA,0DAA0D,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA,kDAAkD,oFAAoF;AACtI;AACA,SAAS;AACT;AACA,gDAAgD,sEAAsE;AACtH;AACA;AACA;;AAEA;AACA,qBAAqB,4DAA4D;AACjF;AACA;AACA;AACA,iDAAiD,gEAAgE;AACjH;AACA;AACA;AACA,0CAA0C,gEAAgE;AAC1G;AACA;;AAEA,iCAAiC,gEAAgE;AACjG;AACA;AACA,iDAAiD,6DAA6D;AAC9G,OAAO;AACP;AACA,yBAAyB,8CAA8C;AACvE;AACA;;AAEA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,iFAAiF;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,iFAAiF;AACzG;AACA;AACA;AACA;AACA,4CAA4C,6DAA6D;AACzG;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA,yDAAyD,0EAA0E;AACnI;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,4DAA4D;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA,+BAA+B,OAAO;AACtC;AACA;AACA,2BAA2B,UAAU,EAAE,gBAAgB,KAAK,KAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,sEAAsE;AAC3G;AACA;AACA,qDAAqD,mEAAmE;AACxH,OAAO;AACP;AACA,6BAA6B,oDAAoD;AACjF;AACA;;AAEA,oBAAoB,oDAAoD;AACxE;AACA;AACA,8CAA8C,oDAAoD;AAClG;AACA;AACA;AACA,2BAA2B,8CAA8C;AACzE;;AAEA;AACA;AACA;AACA,gBAAgB,yDAAyD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2CAA2C;AACnF;AACA;AACA,oCAAoC,2CAA2C;AAC/E;;AAEA,wBAAwB,2CAA2C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB,GAAG,OAAO,GAAG,KAAK;AACvD;AACA,+BAA+B;AAC/B;AACA;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;;AAEA,sBAAsB,2CAA2C;AACjE;AACA;AACA;AACA;AACA,qBAAqB,gBAAgB,GAAG,OAAO,GAAG,KAAK;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAoC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,oCAAoC;AACrD;AACA;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD,OAAO;AACP;;AAEA;AACA;AACA;AACA,gBAAgB,8CAA8C,GAAG,8CAA8C;AAC/G;;AAEA;AACA;AACA;;;;;;;AC9aA,qC;;;;;;ACAA;AACA;AACA;AACA,kBAAkB,2CAA2C,wBAAwB,EAAE;AACvF;AACA;AACA;AACA;;;;;;;ACPA;AACA;AACA;AACA,kBAAkB,sCAAsC,wBAAwB,EAAE;AAClF;AACA;AACA;AACA;;;;;;;ACPA;AACA;AACA;AACA,kBAAkB,0CAA0C,wBAAwB,EAAE;AACtF;AACA;AACA;AACA;;;;;;;ACPA,eAAe,mBAAO,CAAC,CAAoB;AAC3C,gBAAgB,mBAAO,CAAC,CAAqB;AAC7C,eAAe,mBAAO,CAAC,EAAoB;AAC3C,oBAAoB,mBAAO,CAAC,EAAyB;;AAErD;;AAEA;AACA,iBAAiB,mBAAO,CAAC,EAAa;AACtC;AACA,mBAAmB,mBAAO,CAAC,EAAe;AAC1C;AACA,iBAAiB,mBAAO,CAAC,EAAa;AACtC;AACA,eAAe,mBAAO,CAAC,EAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC3BA,qBAAqB,mBAAO,CAAC,CAAoC;;AAEjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;;;;;;AC/CA;;AAEA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;ACfA;AACA,WAAW,mBAAO,CAAC,CAAmB;AACtC;;;;;;;ACFA;AACA;;;;;;;ACDA;AACA;AACA;;;;;;;ACFA,mBAAmB,mBAAO,CAAC,EAA4B;AACvD,eAAe,mBAAO,CAAC,EAAwB;AAC/C,WAAW,mBAAO,CAAC,EAAoB;;AAEvC;AACA;AACA;AACA;AACA;;;;;;;ACRA,aAAa,mBAAO,CAAC,CAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0FAA0F,QAAQ,WAAW,SAAS;AACtH;AACA,6FAA6F,QAAQ,WAAW,SAAS;;AAEzH;AACA;AACA,wCAAwC,sBAAsB;AAC9D;AACA;;;;;;;ACnBA,4BAA4B,mBAAO,CAAC,CAAgC;;AAEpE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B,+BAA+B;AAC5D;AACA,2CAA2C,2BAA2B;AACtE;AACA;;AAEA,eAAe,+BAA+B;AAC9C,yBAAyB,KAAK,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C,OAAO;AACP;;AAEA,yBAAyB,2BAA2B;AACpD;AACA,oDAAoD,2BAA2B;AAC/E;AACA;AACA,8CAA8C,2BAA2B;AACzE,yDAAyD,OAAO,GAAG,iBAAiB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;;;;AC/IA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;;AAEA,uBAAuB,mBAAO,CAAC,CAA2B;AAC1D,2BAA2B,mBAAO,CAAC,CAA+B;AAClE,uBAAuB,mBAAO,CAAC,EAAwB;;AAEvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;;AAEA,qBAAqB,mCAAmC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,cAAc;AACd;;AAEA,kBAAkB,8BAA8B;AAChD,+BAA+B,wCAAwC;AACvE;;AAEA,iBAAiB,8BAA8B;AAC/C,sCAAsC,wCAAwC;AAC9E,cAAc;AACd;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,iBAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC7KA;AACA;;AAEA,oBAAoB,0CAA0C;;AAE9D;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,MAAM;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,iBAAiB;AACvD,OAAO;AACP;AACA;;AAEA;AACA;AACA,kBAAkB,cAAc;AAChC,YAAY;AACZ;AACA,yDAAyD;AACzD,eAAe;AACf;AACA,YAAY;AACZ,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA,aAAa,0BAA0B;;AAEvC;;AAEA;AACA;AACA;AACA,sBAAsB,IAAI,cAAc,OAAO,qBAAqB,YAAY;AAChF;;AAEA;AACA;AACA;;AAEA,YAAY,0BAA0B;;AAEtC;;AAEA;AACA;AACA;AACA,sBAAsB,IAAI,cAAc,OAAO,qBAAqB,YAAY;AAChF;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;;;;;;AC/EA;AACA;AACA;AACA;AACA;;;;;;;ACJA;AACA,aAAa,mBAAO,CAAC,CAAiB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;;;;;;ACnBA,gBAAgB,mBAAO,CAAC,EAAyB;AACjD,WAAW,mBAAO,CAAC,EAAoB;AACvC,qBAAqB,mBAAO,CAAC,EAA8B;AAC3D,gBAAgB,mBAAO,CAAC,EAAyB;;AAEjD;AACA;AACA;AACA,KAAK,oFAAoF;AACzF,KAAK,kFAAkF;AACvF,KAAK,iFAAiF;AACtF;AACA,KAAK,2DAA2D,QAAQ,aAAa,EAAE,EAAE;AACzF,KAAK,6DAA6D,QAAQ,aAAa,EAAE,EAAE;AAC3F,KAAK;AACL,aAAa,QAAQ,gBAAgB,EAAE;AACvC,KAAK;AACL,KAAK;AACL,aAAa,QAAQ,gBAAgB,EAAE;AACvC,KAAK;AACL,KAAK;AACL,aAAa,QAAQ,gBAAgB,EAAE;AACvC,KAAK;AACL;AACA,KAAK;AACL,aAAa,QAAQ,gBAAgB,EAAE;AACvC,KAAK;AACL,KAAK,qFAAqF,QAAQ,aAAa,EAAE,EAAE;AACnH;AACA,KAAK,qEAAqE,QAAQ,aAAa,EAAE,EAAE;AACnG,KAAK,qEAAqE,QAAQ,aAAa,EAAE,EAAE;AACnG,KAAK,oEAAoE,QAAQ,aAAa,EAAE,EAAE;AAClG,KAAK,sEAAsE,QAAQ,aAAa,EAAE,EAAE;AACpG,KAAK,qEAAqE,QAAQ,aAAa,EAAE,EAAE;AACnG;AACA;AACA;;;;;;;ACpCA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACpBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;ACvDA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;ACpBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;ACnDA,gBAAgB,mBAAO,CAAC,EAAsB;AAC9C,WAAW,mBAAO,CAAC,EAAiB;AACpC,qBAAqB,mBAAO,CAAC,EAA2B;AACxD,gBAAgB,mBAAO,CAAC,EAAsB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACbA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;;;;;AClFA;;AAEA;;AAEA,qBAAqB,6BAA6B;AAClD,+CAA+C,6BAA6B;AAC5E;;AAEA,uBAAuB,mBAAmB;AAC1C,iDAAiD,mBAAmB;AACpE;;AAEA,wBAAwB,uCAAuC;AAC/D,kDAAkD,uCAAuC;AACzF;;AAEA,yBAAyB,qDAAqD;AAC9E,mDAAmD,qDAAqD;AACxG;;AAEA,qBAAqB,4DAA4D;AACjF,+CAA+C,4DAA4D;AAC3G;;AAEA;;AAEA;AACA;;;;;;;AC3BA;;AAEA;;AAEA,yBAAyB,2BAA2B;AACpD,gEAAgE,2BAA2B;AAC3F;;AAEA,wBAAwB,eAAe;AACvC;AACA;;AAEA;;AAEA;AACA;;;;;;;ACfA;;AAEA;;AAEA,kBAAkB,8BAA8B;AAChD,oDAAoD,8BAA8B;AAClF;;AAEA,kBAAkB,8BAA8B;AAChD,oDAAoD,8BAA8B;AAClF;;AAEA,iBAAiB,8BAA8B;AAC/C,mDAAmD,8BAA8B;AACjF;;AAEA,mBAAmB,mBAAmB;AACtC,qDAAqD,mBAAmB;AACxE;;AAEA,kBAAkB,mBAAmB;AACrC,oDAAoD,mBAAmB;AACvE;;AAEA;;AAEA;AACA;;;;;;;AC3BA,qBAAqB,mBAAO,CAAC,CAAyB;AACtD,gBAAgB,mBAAO,CAAC,CAAoB;AAC5C,oBAAoB,mBAAO,CAAC,CAAwB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA;AACA,kBAAkB,mBAAO,CAAC,EAAgC;AAC1D;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP,kBAAkB;AAClB;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;;;;;;ACzBA;AACA;AACA;AACA","file":"backend.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","const require3 = require('require3');\nconst uuid = require3('uuid');\n\nconst MessageClassFn = require('./messageClass.js');\nconst MessageFn = require('./message.js');\n\nconst SOCKETSONLINE = Symbol.for('APP#__SOCKETSONLINE');\n\nmodule.exports = ctx => {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class IO {\n\n    constructor() {\n      this._messageClass = null;\n      this._message = null;\n      this._redis = null;\n    }\n\n    get messageClass() {\n      if (!this._messageClass) this._messageClass = new (MessageClassFn(ctx))();\n      return this._messageClass;\n    }\n\n    get message() {\n      if (!this._message) this._message = new (MessageFn(ctx))();\n      return this._message;\n    }\n\n    get redis() {\n      if (!this._redis) this._redis = ctx.app.redis.get('io') || ctx.app.redis.get('cache');\n      return this._redis;\n    }\n\n    _registerSocket(socketId, socket) {\n      const socketsOnline = ctx.app.geto(SOCKETSONLINE);\n      socketsOnline[socketId] = socket;\n    }\n\n    _unRegisterSocket(socketId) {\n      const socketsOnline = ctx.app.geto(SOCKETSONLINE);\n      delete socketsOnline[socketId];\n    }\n\n    // subcribe\n    //    hash key: userId:path\n    //    hash value: scene -> workerId:socketId\n    async subscribe({ subscribes, socketId, user }) {\n      for (const item of subscribes) {\n        const path = item.path;\n        if (!path) ctx.throw(403);\n        const scene = item.scene || '';\n        const key = `${ctx.instance.id}:${user.id}:${path}`;\n        const value = `${ctx.app.meta.workerId}:${socketId}`;\n        await this.redis.hset(key, scene, value);\n      }\n    }\n\n    async unsubscribe({ subscribes, user }) {\n      for (const item of subscribes) {\n        const path = item.path;\n        if (!path) ctx.throw(403);\n        const scene = item.scene || '';\n        const socketId = item.socketId;\n        if (!socketId) continue;\n        const key = `${ctx.instance.id}:${user.id}:${path}`;\n        // check if socketId is consistent\n        const value = await this.redis.hget(key, scene);\n        if (value && value.indexOf(socketId) > -1) {\n          await this.redis.hdel(key, scene);\n        }\n      }\n    }\n\n    async unsubscribeWhenDisconnect({ iid, user, socketId }) {\n      const keyPrefix = this.redis.options.keyPrefix;\n      const keyPatern = `${keyPrefix}${iid}:${user.id}:*`;\n      const keys = await this.redis.keys(keyPatern);\n      for (const fullKey of keys) {\n        const key = fullKey.substr(keyPrefix.length);\n        const values = await this.redis.hgetall(key);\n        if (!values) continue;\n        for (const field in values) {\n          const value = values[field];\n          if (value && value.indexOf(socketId) > -1) {\n            await this.redis.hdel(key, field);\n          }\n        }\n      }\n    }\n\n    async publish({ path, message, messageClass, options }) {\n      // options\n      const messageScene = (options && options.scene) || '';\n      // messageClass\n      messageClass = await this.messageClass.get(messageClass);\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      // message/userId\n      message.userIdFrom = parseInt(message.userIdFrom || 0);\n      if (message.userIdTo === undefined || message.userIdTo === null) message.userIdTo = -2;\n      message.userIdTo = parseInt(message.userIdTo || 0);\n      const userIdFrom = message.userIdFrom;\n      const userIdTo = message.userIdTo;\n      // sessionId\n      let sessionId;\n      if (messageClassBase.callbacks.onSessionId) {\n        sessionId = await messageClassBase.callbacks.onSessionId({ io: this, ctx, path, message, options });\n      }\n      if (!sessionId) {\n        sessionId = message.messageGroup ? userIdTo : this._combineSessionId(userIdFrom, userIdTo);\n      }\n      // message\n      const _message = {\n        messageClassId: messageClass.id,\n        messageType: message.messageType,\n        messageFilter: message.messageFilter,\n        messageGroup: message.messageGroup,\n        messageScene,\n        userIdTo,\n        userIdFrom,\n        sessionId,\n        content: JSON.stringify(message.content), // should use string for db/queue\n      };\n\n      // save\n      if (messageClassBase.info.persistence) {\n        _message.id = await this.message.save({ message: _message });\n      } else {\n        _message.id = message.id || uuid.v4();\n        _message.createdAt = new Date();\n      }\n\n      // to queue\n      ctx.app.meta.queue.push({\n        subdomain: ctx.subdomain,\n        module: moduleInfo.relativeName,\n        queueName: 'process',\n        data: {\n          path,\n          options,\n          message: _message,\n          messageClass,\n        },\n      });\n\n      // ok\n      return {\n        id: _message.id,\n      };\n    }\n\n    // queue: process\n    async queueProcess({ path, options, message, messageClass }) {\n      // messageClass\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      // groupUsers\n      let groupUsers;\n      if (messageClassBase.callbacks.onGroupUsers) {\n        groupUsers = await messageClassBase.callbacks.onGroupUsers({ io: this, ctx, path, message, options });\n      }\n      // onProcess\n      if (messageClassBase.callbacks.onProcess) {\n        await messageClassBase.callbacks.onProcess({ io: this, ctx, path, options, message, groupUsers, messageClass });\n      }\n      // save syncs\n      const messageSyncs = await this.message.saveSyncs({\n        message,\n        groupUsers,\n        persistence: messageClassBase.info.persistence,\n      });\n      // to queue: delivery/push\n      if (path) {\n        // delivery\n        ctx.app.meta.queue.push({\n          subdomain: ctx.subdomain,\n          module: moduleInfo.relativeName,\n          queueName: 'delivery',\n          data: {\n            path,\n            options,\n            message,\n            messageSyncs,\n            messageClass,\n          },\n        });\n      } else {\n        // push\n        this._pushQueuePush({ options, message, messageSyncs, messageClass });\n      }\n    }\n\n    // queue: delivery\n    async queueDelivery({ path, options, message, messageSyncs, messageClass }) {\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      for (const messageSync of messageSyncs) {\n        if (messageSync.userId === -1 && path) {\n          // broadcast to online users\n          const userIds = await this._getPathUsersOnline({ path });\n          for (const userId of userIds) {\n            const _messageSync = {\n              ...messageSync,\n              userId,\n            };\n            await this._queueDeliveryMessageSync({ messageClassBase, path, options, message, messageSync: _messageSync, messageClass });\n          }\n        } else {\n          // normal\n          await this._queueDeliveryMessageSync({ messageClassBase, path, options, message, messageSync, messageClass });\n        }\n      }\n    }\n\n    // queue: push\n    async queuePush({ options, message, messageSyncs, messageSync, messageClass }) {\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      if (messageSync) {\n        // only one message\n        return await this._queuePushMessageSync({ messageClassBase, options, message, messageSync, messageClass });\n      }\n      // more messages\n      for (const messageSync of messageSyncs) {\n        await this._queuePushMessageSync({ messageClassBase, options, message, messageSync, messageClass });\n      }\n    }\n\n    async _queuePushMessageSync({ messageClassBase, options, message, messageSync, messageClass }) {\n      if (messageClassBase.callbacks.onPush) {\n        // custom\n        await messageClassBase.callbacks.onPush({ io: this, ctx, options, message, messageSync, messageClass });\n      } else {\n        // default\n        await this.push({ options, message, messageSync, messageClass });\n      }\n    }\n\n    async push({ options, message, messageSync, messageClass }) {\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      // userId\n      const userId = messageSync.userId;\n      const isSender = message.userIdFrom === userId;\n      // ignore sender\n      if (isSender) return true;\n      // options maybe set push.channels\n      let channels = options && options.push && options.channels;\n      if (!channels) channels = messageClassBase.info.push.channels;\n      if (!channels) return false;\n      // adjust auto\n      let autoFirstValid = false;\n      if (channels === 'auto') {\n        autoFirstValid = true;\n        channels = Object.keys(messageClassBase.channels);\n      }\n      // loop\n      let atLeastDone = false;\n      for (const channelFullName of channels) {\n        const res = await this._pushChannel({ messageClassBase, options, message, messageSync, messageClass, channelFullName });\n        if (!res) continue;\n        atLeastDone = true;\n        if (autoFirstValid) break;\n      }\n      // log\n      if (!atLeastDone) {\n        ctx.logger.info('not found any valid channel for this message:', message);\n        return false;\n      }\n      // done\n      return true;\n    }\n\n    async _pushChannel({ messageClassBase, options, message, messageSync, messageClass, channelFullName }) {\n      try {\n        // render message content\n        const onRender = messageClassBase.channels[channelFullName] && messageClassBase.channels[channelFullName].onRender;\n        if (!onRender) return false;\n        const pushContent = await onRender({ io: this, ctx, options, message, messageSync, messageClass });\n        if (!pushContent) return false;\n        // get channel base\n        const channelBase = this.messageClass.channel(channelFullName);\n        if (!channelBase) {\n          ctx.logger.info(`channel not found: ${channelFullName}`);\n          return false;\n        }\n        // push\n        let pushDone = false;\n        if (channelBase.callbacks.onPush) {\n          pushDone = await channelBase.callbacks.onPush({ io: this, ctx, options, message, messageSync, messageClass, pushContent });\n        }\n        if (!pushDone) return false;\n        // done this channel\n        return true;\n      } catch (err) {\n        // log\n        ctx.logger.error(err);\n        return false;\n      }\n    }\n\n    _pushQueuePush({ options, message, messageSyncs, messageSync, messageClass }) {\n      const messageClassBase = this.messageClass.messageClass(messageClass);\n      // check if enable push\n      const infoPush = messageClassBase.info && messageClassBase.info.push;\n      if (infoPush && infoPush.channels) {\n        ctx.app.meta.queue.push({\n          subdomain: ctx.subdomain,\n          module: moduleInfo.relativeName,\n          queueName: 'push',\n          data: {\n            options,\n            message,\n            messageSyncs,\n            messageSync,\n            messageClass,\n          },\n        });\n      }\n    }\n\n    async _getPathUsersOnline({ path }) {\n      const userIds = [];\n      const keyPrefix = this.redis.options.keyPrefix;\n      const keyPatern = `${keyPrefix}${ctx.instance.id}:*:${path}`;\n      const keys = await this.redis.keys(keyPatern);\n      for (const fullKey of keys) {\n        const key = fullKey.substr(keyPrefix.length);\n        userIds.push(parseInt(key.split(':')[1]));\n      }\n      return userIds;\n    }\n\n    async _queueDeliveryMessageSync({ messageClassBase, path, options, message, messageSync, messageClass }) {\n      if (messageClassBase.callbacks.onDelivery) {\n        // custom\n        await messageClassBase.callbacks.onDelivery({ io: this, ctx, path, options, message, messageSync, messageClass });\n      } else {\n        // default\n        await this.delivery({ path, options, message, messageSync, messageClass });\n      }\n    }\n\n    async delivery({ path, options, message, messageSync, messageClass }) {\n      // ignore delivery online if !path\n      if (path) {\n        const deliveryDone = await this.emit({ path, options, message, messageSync, messageClass });\n        if (deliveryDone) return;\n      }\n      // to queue: push\n      this._pushQueuePush({ options, message, messageSync, messageClass });\n    }\n\n    // offline: return false\n    //    hash key: userId:path\n    //    hash value: scene -> workerId:socketId\n    async emit({ path, options, message, messageSync/* , messageClass*/ }) {\n      // userId\n      const userId = messageSync.userId;\n      if (!userId) return true;\n      // options\n      const messageScene = (options && options.scene) || '';\n      // no scene\n      if (!messageScene) {\n        return await this._emitNoScene({ path, message, messageSync, messageScene });\n      }\n      // scene\n      return await this._emitScene({ path, message, messageSync, messageScene });\n    }\n\n    async _emitNoScene({ path, message, messageSync, messageScene }) {\n      // userId\n      const userId = messageSync.userId;\n      const isSender = message.userIdFrom === userId;\n      // ignore sender\n      if (isSender) return true;\n      // get hash value\n      const key = `${ctx.instance.id}:${userId}:${path}`;\n      const value = await this.redis.hget(key, messageScene);\n      if (!value) return false; // offline\n      // emit\n      const [ workerId, socketId ] = value.split(':');\n      this._emitSocket({ path, message, workerId, socketId });\n      // done\n      return true;\n    }\n\n    async _emitScene({ path, message, messageSync, messageScene }) {\n      // userId\n      const userId = messageSync.userId;\n      const isSender = message.userIdFrom === userId;\n      // get hash value\n      const key = `${ctx.instance.id}:${userId}:${path}`;\n      const values = await this.redis.hgetall(key);\n      if (!values) {\n        // offline\n        //  only support offline-notification for receiver\n        return !!isSender;\n      }\n      let bSent = false;\n      for (const field in values) {\n        if (!isSender || field !== messageScene) {\n          bSent = true;\n          const value = values[field];\n          const [ workerId, socketId ] = value.split(':');\n          this._emitSocket({ path, message, workerId, socketId });\n        }\n      }\n      if (!bSent) {\n        // offline\n        //  only support offline-notification for receiver\n        return !!isSender;\n      }\n      // done\n      return true;\n    }\n\n    _emitSocket({ path, message, workerId, socketId }) {\n      // broadcast\n      ctx.app.meta.broadcast.emit({\n        subdomain: ctx.subdomain,\n        module: moduleInfo.relativeName,\n        broadcastName: 'socketEmit',\n        data: { path, message, workerId, socketId },\n      });\n    }\n\n    // combine sessionId\n    _combineSessionId(userIdFrom, userIdTo) {\n      if (userIdFrom === userIdTo) return userIdFrom;\n      return `${userIdFrom > userIdTo ? userIdFrom : userIdTo}:${userIdFrom < userIdTo ? userIdFrom : userIdTo}`;\n    }\n\n  }\n  return IO;\n};\n","module.exports = require(\"require3\");","module.exports = app => {\n  class MessageClass extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aSocketIOMessageClass', options: { disableDeleted: false } });\n    }\n  }\n  return MessageClass;\n};\n","module.exports = app => {\n  class Message extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aSocketIOMessage', options: { disableDeleted: false } });\n    }\n  }\n  return Message;\n};\n","module.exports = app => {\n  class MessageSync extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aSocketIOMessageSync', options: { disableDeleted: false } });\n    }\n  }\n  return MessageSync;\n};\n","const config = require('./config/config.js');\nconst locales = require('./config/locales.js');\nconst errors = require('./config/errors.js');\nconst middlewares = require('./config/middlewares.js');\n\nmodule.exports = app => {\n\n  // routes\n  const routes = require('./routes.js')(app);\n  // services\n  const services = require('./services.js')(app);\n  // models\n  const models = require('./models.js')(app);\n  // meta\n  const meta = require('./meta.js')(app);\n\n  return {\n    routes,\n    services,\n    models,\n    config,\n    locales,\n    errors,\n    middlewares,\n    meta,\n  };\n\n};\n","const onSocketEmit = require('./middleware/adapter/socketEmit.js');\n\n// eslint-disable-next-line\nmodule.exports = appInfo => {\n  const config = {};\n\n  // middlewares\n  config.middlewares = {\n    connection: {\n      type: 'socketio.connection',\n    },\n    packet: {\n      type: 'socketio.packet',\n    },\n    io: {\n      global: true,\n      dependencies: 'instance',\n    },\n  };\n\n  // queues\n  config.queues = {\n    registerMessageClass: {\n      path: 'messageClass/queueRegister',\n    },\n    process: {\n      path: 'io/queueProcess',\n      concurrency: true,\n    },\n    delivery: {\n      path: 'io/queueDelivery',\n      concurrency: true,\n    },\n    push: {\n      path: 'io/queuePush',\n      concurrency: true,\n    },\n  };\n\n  // broadcasts\n  config.broadcasts = {\n    socketEmit: {\n      callback: onSocketEmit,\n    },\n  };\n\n  return config;\n};\n","const SOCKETSONLINE = Symbol.for('APP#__SOCKETSONLINE');\n\nmodule.exports = app => {\n  return async function({ data }) {\n    if (app.meta.workerId === data.workerId) {\n      const socketsOnline = app.geto(SOCKETSONLINE);\n      const socket = socketsOnline[data.socketId];\n      if (socket) {\n        socket.emit('message', {\n          path: data.path,\n          message: data.message,\n        });\n      }\n    }\n  };\n};\n","module.exports = {\n  'zh-cn': require('./locale/zh-cn.js'),\n};\n","module.exports = {\n};\n","// error code should start from 1001\nmodule.exports = {\n};\n","const connection = require('./middleware/connection.js');\nconst packet = require('./middleware/packet.js');\nconst io = require('./middleware/io.js');\n\nmodule.exports = {\n  connection,\n  packet,\n  io,\n};\n","const IOFn = require('./adapter/io.js');\nmodule.exports = (options, app) => {\n  return async (ctx, next) => {\n    const io = new (IOFn(ctx))();\n    // cache userId/socketId for disconnect\n    const user = ctx.session.passport.user.op;\n    if (user.anonymous) return ctx.throw(403);\n    const iid = user.iid;\n    const socketId = ctx.socket.id;\n    io._registerSocket(socketId, ctx.socket);\n\n    if (app.meta.isTest || app.meta.isLocal) app.logger.info(`socket io connected: user:${user.id}, socket:${socketId}`);\n    await next();\n    if (app.meta.isTest || app.meta.isLocal) app.logger.info(`socket io disconnected: user:${user.id}, socket:${socketId}`);\n\n    // execute when disconnect\n    io._unRegisterSocket(socketId);\n    await io.unsubscribeWhenDisconnect({ iid, user, socketId });\n  };\n};\n","const modelMessageClassFn = require('../../../model/messageClass.js');\n\nconst _cacheMessageClasses = {};\nconst _cacheChannels = {};\n\nmodule.exports = ctx => {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class MessageClass {\n\n    constructor() {\n      this._modelMessageClass = null;\n    }\n\n    get modelMessageClass() {\n      if (!this._modelMessageClass) this._modelMessageClass = new (modelMessageClassFn(ctx.app))(ctx);\n      return this._modelMessageClass;\n    }\n\n    async getMessageClassId({ id, module, messageClassName }) {\n      if (id) return id;\n      const messageClass = await this.get({ module, messageClassName });\n      return messageClass.id;\n    }\n\n    async get({ id, module, messageClassName }) {\n      const data = id ? { id } : { module, messageClassName };\n      const res = await this.modelMessageClass.get(data);\n      if (res) return res;\n      if (!module || !messageClassName) throw new Error('Invalid arguments');\n      // queue\n      return await ctx.app.meta.queue.pushAsync({\n        subdomain: ctx.subdomain,\n        module: moduleInfo.relativeName,\n        queueName: 'registerMessageClass',\n        data: { module, messageClassName },\n      });\n    }\n\n    async queueRegister({ module, messageClassName }) {\n      // get\n      const res = await this.modelMessageClass.get({ module, messageClassName });\n      if (res) return res;\n      // data\n      const messageClass = this.messageClass({ module, messageClassName });\n      if (!messageClass) throw new Error(`messageClass ${module}:${messageClassName} not found!`);\n      const data = {\n        module,\n        messageClassName,\n      };\n      // insert\n      const res2 = await this.modelMessageClass.insert(data);\n      data.id = res2.insertId;\n      return data;\n    }\n\n    messageClasses() {\n      if (!_cacheMessageClasses[ctx.locale]) {\n        _cacheMessageClasses[ctx.locale] = this._prepareMessageClasses();\n      }\n      return _cacheMessageClasses[ctx.locale];\n    }\n\n    messageClass({ module, messageClassName }) {\n      const _messageClasses = this.messageClasses();\n      return _messageClasses[module] && _messageClasses[module][messageClassName];\n    }\n\n    _prepareMessageClasses() {\n      const messageClasses = {};\n      for (const relativeName in ctx.app.meta.modules) {\n        const module = ctx.app.meta.modules[relativeName];\n        if (module.main.meta && module.main.meta.socketio && module.main.meta.socketio.messages) {\n          const res = this._prepareMessageClassesModule(module, module.main.meta.socketio.messages);\n          if (Object.keys(res).length > 0) {\n            messageClasses[relativeName] = res;\n          }\n        }\n      }\n      return messageClasses;\n    }\n\n    _prepareMessageClassesModule(module, _messages) {\n      const messageClasses = {};\n      for (const key in _messages) {\n        const _message = _messages[key];\n        // titleLocale\n        _message.info.titleLocale = ctx.text(_message.info.title);\n        // ok\n        messageClasses[key] = _message;\n      }\n      return messageClasses;\n    }\n\n    channels() {\n      if (!_cacheChannels[ctx.locale]) {\n        _cacheChannels[ctx.locale] = this._prepareChannels();\n      }\n      return _cacheChannels[ctx.locale];\n    }\n\n    // string/object\n    channel(channelFullName) {\n      let module,\n        channelName;\n      if (typeof channelFullName === 'string') {\n        [ module, channelName ] = channelFullName.split(':');\n      } else {\n        module = channelFullName.module;\n        channelName = channelFullName.channelName;\n      }\n      const _channels = this.channels();\n      return _channels[module] && _channels[module][channelName];\n    }\n\n    _prepareChannels() {\n      const channels = {};\n      for (const relativeName in ctx.app.meta.modules) {\n        const module = ctx.app.meta.modules[relativeName];\n        if (module.main.meta && module.main.meta.socketio && module.main.meta.socketio.channels) {\n          const res = this._prepareChannelsModule(module, module.main.meta.socketio.channels);\n          if (Object.keys(res).length > 0) {\n            channels[relativeName] = res;\n          }\n        }\n      }\n      return channels;\n    }\n\n    _prepareChannelsModule(module, _channels) {\n      const channels = {};\n      for (const key in _channels) {\n        const _channel = _channels[key];\n        // titleLocale\n        _channel.info.titleLocale = ctx.text(_channel.info.title);\n        // ok\n        channels[key] = _channel;\n      }\n      return channels;\n    }\n\n\n  }\n  return MessageClass;\n};\n","const require3 = require('require3');\nconst uuid = require3('uuid');\n\nconst modelMessageFn = require('../../../model/message.js');\nconst modelMessageSyncFn = require('../../../model/messageSync.js');\nconst sqlProcedureFn = require('../../sql/procedure.js');\n\nmodule.exports = ctx => {\n  // const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class MessageClass {\n\n    constructor() {\n      this._modelMessage = null;\n      this._modelMessageSync = null;\n      this._sqlProcedure = null;\n    }\n\n    get modelMessage() {\n      if (!this._modelMessage) this._modelMessage = new (modelMessageFn(ctx.app))(ctx);\n      return this._modelMessage;\n    }\n\n    get modelMessageSync() {\n      if (!this._modelMessageSync) this._modelMessageSync = new (modelMessageSyncFn(ctx.app))(ctx);\n      return this._modelMessageSync;\n    }\n\n    get sqlProcedure() {\n      if (!this._sqlProcedure) this._sqlProcedure = new (sqlProcedureFn(ctx))();\n      return this._sqlProcedure;\n    }\n\n    async save({ message }) {\n      // insert\n      const res = await this.modelMessage.insert(message);\n      return res.insertId;\n    }\n\n    async saveSyncs({ message, groupUsers, persistence }) {\n      // messageId\n      const messageId = message.id;\n      // message sync\n      const messageSyncs = [];\n      //  :userIdFrom\n      const isSame = message.userIdTo === message.userIdFrom;\n      messageSyncs.push({\n        messageId,\n        userId: message.userIdFrom,\n        messageDirection: isSame ? 0 : 1, // self/send\n        messageRead: 1,\n      });\n      //  :userIdTo\n      if (!message.messageGroup) {\n        // single chat\n        if (!isSame) {\n          messageSyncs.push({\n            messageId,\n            userId: message.userIdTo,\n            messageDirection: 2, // receive\n            messageRead: 0,\n          });\n        }\n      } else {\n        // group chat\n        if (groupUsers) {\n          for (const groupUser of groupUsers) {\n            const _userIdTo = groupUser.userId;\n            if (_userIdTo !== message.userIdFrom) {\n              messageSyncs.push({\n                messageId,\n                userId: _userIdTo,\n                messageDirection: 2, // receive\n                messageRead: 0,\n              });\n            }\n          }\n        }\n      }\n      //  :save\n      for (const messageSync of messageSyncs) {\n        if (persistence) {\n          const res = await this.modelMessageSync.insert(messageSync);\n          messageSync.messageSyncId = res.insertId;\n        } else {\n          messageSync.messageSyncId = uuid.v4();\n        }\n      }\n      // ok\n      return messageSyncs;\n    }\n\n    // the first unread message\n    // options:\n    //    where\n    async offset({ messageClass, options, user }) {\n      // messageClass\n      messageClass = await ctx.meta.io.messageClass.get(messageClass);\n      // where\n      const where = (options && options.where) || {};\n      where.iid = ctx.instance.id;\n      where.deleted = 0;\n      where.syncDeleted = 0;\n      where.messageClassId = messageClass.id;\n      where.userId = user ? user.id : 0;\n      where.messageRead = 0;\n      // offset\n      const res = await ctx.db.select('aSocketIOMessageView', {\n        where,\n        columns: [ 'id' ],\n        orders: [[ 'id', 'asc' ]],\n        limit: 1,\n        offset: 0,\n      });\n      // offset - 1\n      const offset = res[0] ? res[0].id - 1 : -1;\n      return { offset };\n    }\n\n    async select({ messageClass, options, user }) {\n      return await this._list({ messageClass, options, user, count: 0 });\n    }\n\n    async count({ messageClass, options, user }) {\n      const count = await this._list({ messageClass, options, user, count: 1 });\n      return { count };\n    }\n\n    async setRead({ messageIds, user }) {\n      if (!messageIds || messageIds.length === 0) return;\n      // query\n      const sql = this.sqlProcedure.setRead({\n        iid: ctx.instance.id,\n        messageIds,\n        userId: user ? user.id : 0,\n      });\n      await ctx.model.query(sql);\n    }\n\n    async delete({ messageIds, user }) {\n      if (!messageIds || messageIds.length === 0) return;\n      // query\n      const sql = this.sqlProcedure.delete({\n        iid: ctx.instance.id,\n        messageIds,\n        userId: user ? user.id : 0,\n      });\n      await ctx.model.query(sql);\n    }\n\n    async _list({ messageClass, options, user, count }) {\n      // messageClass\n      messageClass = await ctx.meta.io.messageClass.get(messageClass);\n      // where\n      const where = (options && options.where) || {};\n      where.messageClassId = messageClass.id;\n      where.userId = user ? user.id : 0;\n      // orders\n      const orders = (options && options.orders) || [[ 'createdAt', 'asc' ]];\n      // query\n      const sql = this.sqlProcedure.selectMessages({\n        iid: ctx.instance.id,\n        where,\n        orders,\n        page: options.page,\n        offset: options.offset,\n        count,\n      });\n      const res = await ctx.model.query(sql);\n      return count ? res[0]._count : res;\n    }\n\n  }\n  return MessageClass;\n};\n","module.exports = ctx => {\n  class Procedure {\n\n    selectMessages({ iid, where, orders, page, offset, count }) {\n\n      // for safe\n      where = where ? ctx.model._where(where) : null;\n      orders = orders ? ctx.model._orders(orders) : null;\n      const limit = page ? ctx.model._limit(page.size, page.index) : null;\n\n      //\n      const _where = where ? `${where} AND` : ' WHERE';\n      const _orders = orders || '';\n      const _limit = limit || '';\n\n      // fields\n      let _selectFields;\n      if (count) {\n        _selectFields = 'count(*) as _count';\n      } else {\n        _selectFields = 'a.*';\n      }\n\n      // offset\n      let _offsetWhere;\n      if (typeof offset === 'number') {\n        _offsetWhere = ` and a.id > ${parseInt(offset)}`;\n      } else {\n        _offsetWhere = '';\n      }\n\n      // sql\n      const _sql =\n        `select ${_selectFields} from aSocketIOMessageView a\n          ${_where}\n           (\n             a.deleted=0 and a.syncDeleted=0 and a.iid=${iid}\n             ${_offsetWhere}\n           )\n          ${count ? '' : _orders}\n          ${count ? '' : _limit}\n        `;\n\n      // ok\n      return _sql;\n    }\n\n    setRead({ iid, messageIds, userId }) {\n\n      const _messageIds = messageIds.map(item => parseInt(item)).join(',');\n\n      // sql\n      const _sql =\n        `update aSocketIOMessageSync set messageRead=1\n          where iid=${iid} and userId=${userId} and messageId in (${_messageIds})\n        `;\n\n      // ok\n      return _sql;\n    }\n\n    delete({ iid, messageIds, userId }) {\n\n      const _messageIds = messageIds.map(item => parseInt(item)).join(',');\n\n      // sql\n      const _sql =\n        `update aSocketIOMessageSync set deleted=1\n          where iid=${iid} and userId=${userId} and messageId in (${_messageIds})\n        `;\n\n      // ok\n      return _sql;\n    }\n\n  }\n\n  return Procedure;\n\n};\n","module.exports = (options, app) => {\n  return async (ctx, next) => {\n    await next();\n  };\n};\n","// io\nconst IOFn = require('./adapter/io.js');\nconst IO = Symbol('CTX#__IO');\n\nmodule.exports = () => {\n  return async function io(ctx, next) {\n    ctx.meta = ctx.meta || {};\n    // io\n    Object.defineProperty(ctx.meta, 'io', {\n      get() {\n        if (ctx.meta[IO] === undefined) {\n          ctx.meta[IO] = new (IOFn(ctx))();\n        }\n        return ctx.meta[IO];\n      },\n    });\n    // next\n    await next();\n  };\n};\n","const version = require('./controller/version.js');\nconst io = require('./controller/io.js');\nconst messageClass = require('./controller/messageClass.js');\nconst message = require('./controller/message.js');\n\nmodule.exports = app => {\n  const routes = [\n    // version\n    { method: 'post', path: 'version/update', controller: version, middlewares: 'inner' },\n    { method: 'post', path: 'version/init', controller: version, middlewares: 'inner' },\n    { method: 'post', path: 'version/test', controller: version, middlewares: 'test' },\n    // io\n    { method: 'post', path: 'subscribe', controller: io, meta: { auth: { user: true } } },\n    { method: 'post', path: 'unsubscribe', controller: io, meta: { auth: { user: true } } },\n    { method: 'post', path: 'io/queueProcess', controller: io, middlewares: 'inner',\n      meta: { auth: { enable: false } },\n    },\n    { method: 'post', path: 'io/queueDelivery', controller: io, middlewares: 'inner',\n      meta: { auth: { enable: false } },\n    },\n    { method: 'post', path: 'io/queuePush', controller: io, middlewares: 'inner',\n      meta: { auth: { enable: false } },\n    },\n    // messageClass\n    { method: 'post', path: 'messageClass/queueRegister', controller: messageClass, middlewares: 'inner',\n      meta: { auth: { enable: false } },\n    },\n    { method: 'post', path: 'messageClass/messageClass', controller: messageClass, meta: { auth: { user: true } } },\n    // message\n    { method: 'post', path: 'message/offset', controller: message, meta: { auth: { user: true } } },\n    { method: 'post', path: 'message/select', controller: message, meta: { auth: { user: true } } },\n    { method: 'post', path: 'message/count', controller: message, meta: { auth: { user: true } } },\n    { method: 'post', path: 'message/setRead', controller: message, meta: { auth: { user: true } } },\n    { method: 'post', path: 'message/delete', controller: message, meta: { auth: { user: true } } },\n  ];\n  return routes;\n};\n","module.exports = app => {\n  class VersionController extends app.Controller {\n\n    async update() {\n      await this.service.version.update(this.ctx.request.body);\n      this.ctx.success();\n    }\n\n    async init() {\n      await this.service.version.init(this.ctx.request.body);\n      this.ctx.success();\n    }\n\n    async test() {\n      await this.service.version.test(this.ctx.request.body);\n      this.ctx.success();\n    }\n\n  }\n  return VersionController;\n};\n","module.exports = app => {\n  class IOController extends app.Controller {\n\n    async subscribe() {\n      const res = await this.service.io.subscribe({\n        subscribes: this.ctx.request.body.subscribes,\n        socketId: this.ctx.request.body.socketId,\n        user: this.ctx.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async unsubscribe() {\n      const res = await this.service.io.unsubscribe({\n        subscribes: this.ctx.request.body.subscribes,\n        user: this.ctx.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async queueProcess() {\n      const res = await this.service.io.queueProcess({\n        path: this.ctx.request.body.path,\n        options: this.ctx.request.body.options,\n        message: this.ctx.request.body.message,\n        messageClass: this.ctx.request.body.messageClass,\n      });\n      this.ctx.success(res);\n    }\n\n    async queueDelivery() {\n      const res = await this.service.io.queueDelivery({\n        path: this.ctx.request.body.path,\n        options: this.ctx.request.body.options,\n        message: this.ctx.request.body.message,\n        messageSyncs: this.ctx.request.body.messageSyncs,\n        messageClass: this.ctx.request.body.messageClass,\n      });\n      this.ctx.success(res);\n    }\n\n    async queuePush() {\n      // messageSyncs/messageSync\n      const res = await this.service.io.queuePush({\n        options: this.ctx.request.body.options,\n        message: this.ctx.request.body.message,\n        messageSyncs: this.ctx.request.body.messageSyncs,\n        messageSync: this.ctx.request.body.messageSync,\n        messageClass: this.ctx.request.body.messageClass,\n      });\n      this.ctx.success(res);\n    }\n\n  }\n  return IOController;\n};\n","module.exports = app => {\n  class MessageClassController extends app.Controller {\n\n    async queueRegister() {\n      const res = await this.ctx.service.messageClass.queueRegister({\n        module: this.ctx.request.body.module,\n        messageClassName: this.ctx.request.body.messageClassName,\n      });\n      this.ctx.success(res);\n    }\n\n    async messageClass() {\n      const res = await this.ctx.service.messageClass.messageClass({\n        messageClass: this.ctx.request.body.messageClass,\n      });\n      this.ctx.success(res);\n    }\n\n  }\n  return MessageClassController;\n};\n","module.exports = app => {\n  class MessageController extends app.Controller {\n\n    async offset() {\n      const res = await this.ctx.service.message.offset({\n        messageClass: this.ctx.request.body.messageClass,\n        options: this.ctx.request.body.options,\n        user: this.ctx.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async select() {\n      const options = this.ctx.request.body.options;\n      options.page = this.ctx.meta.util.page(options.page);\n      const items = await this.ctx.service.message.select({\n        messageClass: this.ctx.request.body.messageClass,\n        options,\n        user: this.ctx.user.op,\n      });\n      this.ctx.successMore(items, options.page.index, options.page.size);\n    }\n\n    async count() {\n      const options = this.ctx.request.body.options;\n      const count = await this.ctx.service.message.count({\n        messageClass: this.ctx.request.body.messageClass,\n        options,\n        user: this.ctx.user.op,\n      });\n      this.ctx.success(count);\n    }\n\n    async setRead() {\n      const res = await this.ctx.service.message.setRead({\n        messageIds: this.ctx.request.body.messageIds,\n        user: this.ctx.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n    async delete() {\n      const res = await this.ctx.service.message.delete({\n        messageIds: this.ctx.request.body.messageIds,\n        user: this.ctx.user.op,\n      });\n      this.ctx.success(res);\n    }\n\n  }\n  return MessageController;\n};\n","const version = require('./service/version.js');\nconst io = require('./service/io.js');\nconst messageClass = require('./service/messageClass.js');\nconst message = require('./service/message.js');\n\nmodule.exports = app => {\n  const services = {\n    version,\n    io,\n    messageClass,\n    message,\n  };\n  return services;\n};\n","module.exports = app => {\n\n  class Version extends app.Service {\n\n    async update(options) {\n      if (options.version === 1) {\n        let sql;\n\n        // create table: aSocketIOMessageClass\n        sql = `\n          CREATE TABLE aSocketIOMessageClass (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT '0',\n            iid int(11) DEFAULT '0',\n            module varchar(255) DEFAULT NULL,\n            messageClassName varchar(255) DEFAULT NULL,\n            PRIMARY KEY (id)\n          )\n        `;\n        await this.ctx.model.query(sql);\n\n        // create table: aSocketIOMessage\n        sql = `\n          CREATE TABLE aSocketIOMessage (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT '0',\n            iid int(11) DEFAULT '0',\n            messageClassId int(11) DEFAULT '0',\n            messageType int(11) DEFAULT '0',\n            messageFilter varchar(255) DEFAULT NULL,\n            messageGroup int(11) DEFAULT '0',\n            messageScene varchar(50) DEFAULT NULL,\n            userIdTo int(11) DEFAULT '0',\n            userIdFrom int(11) DEFAULT '0',\n            sessionId varchar(255) DEFAULT NULL,\n            content json DEFAULT NULL,\n            PRIMARY KEY (id)\n          )\n        `;\n        await this.ctx.model.query(sql);\n\n        // create table: aSocketIOMessageSync\n        sql = `\n          CREATE TABLE aSocketIOMessageSync (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT '0',\n            iid int(11) DEFAULT '0',\n            messageId int(11) DEFAULT '0',\n            userId int(11) DEFAULT '0',\n            messageDirection int(11) DEFAULT '0',\n            messageRead int(11) DEFAULT '0',\n            PRIMARY KEY (id)\n          )\n        `;\n        await this.ctx.model.query(sql);\n\n        // create view: aSocketIOMessageView\n        sql = `\n          CREATE VIEW aSocketIOMessageView as\n            select a.*,b.userId,b.messageDirection,b.messageRead,b.deleted as syncDeleted from aSocketIOMessage a\n              left join aSocketIOMessageSync b on a.id=b.messageId\n        `;\n        await this.ctx.model.query(sql);\n\n      }\n    }\n\n    async init(options) {\n    }\n\n    async test() {\n    }\n\n  }\n\n  return Version;\n};\n","module.exports = app => {\n\n  class IO extends app.Service {\n\n    async subscribe({ subscribes, socketId, user }) {\n      return await this.ctx.meta.io.subscribe({ subscribes, socketId, user });\n    }\n\n    async unsubscribe({ subscribes, user }) {\n      return await this.ctx.meta.io.unsubscribe({ subscribes, user });\n    }\n\n    async queueProcess({ path, options, message, messageClass }) {\n      return await this.ctx.meta.io.queueProcess({ path, options, message, messageClass });\n    }\n\n    async queueDelivery({ path, options, message, messageSyncs, messageClass }) {\n      return await this.ctx.meta.io.queueDelivery({ path, options, message, messageSyncs, messageClass });\n    }\n\n    async queuePush({ options, message, messageSyncs, messageSync, messageClass }) {\n      return await this.ctx.meta.io.queuePush({ options, message, messageSyncs, messageSync, messageClass });\n    }\n\n  }\n\n  return IO;\n};\n","module.exports = app => {\n\n  class MessageClass extends app.Service {\n\n    async queueRegister({ module, messageClassName }) {\n      return await this.ctx.meta.io.messageClass.queueRegister({ module, messageClassName });\n    }\n\n    async messageClass({ messageClass }) {\n      return await this.ctx.meta.io.messageClass.get(messageClass);\n    }\n\n  }\n\n  return MessageClass;\n};\n","module.exports = app => {\n\n  class Message extends app.Service {\n\n    async offset({ messageClass, options, user }) {\n      return await this.ctx.meta.io.message.offset({ messageClass, options, user });\n    }\n\n    async select({ messageClass, options, user }) {\n      return await this.ctx.meta.io.message.select({ messageClass, options, user });\n    }\n\n    async count({ messageClass, options, user }) {\n      return await this.ctx.meta.io.message.count({ messageClass, options, user });\n    }\n\n    async setRead({ messageIds, user }) {\n      return await this.ctx.meta.io.message.setRead({ messageIds, user });\n    }\n\n    async delete({ messageIds, user }) {\n      return await this.ctx.meta.io.message.delete({ messageIds, user });\n    }\n\n  }\n\n  return Message;\n};\n","const messageClass = require('./model/messageClass.js');\nconst message = require('./model/message.js');\nconst messageSync = require('./model/messageSync.js');\n\nmodule.exports = app => {\n  const models = {\n    messageClass,\n    message,\n    messageSync,\n  };\n  return models;\n};\n","module.exports = app => {\n  const schemas = require('./config/validation/schemas.js')(app);\n  const meta = {\n    base: {\n      atoms: {\n      },\n      functions: {\n      },\n    },\n    validation: {\n      validators: {\n      },\n      keywords: {},\n      schemas: {\n      },\n    },\n    index: {\n      indexes: {\n        aSocketIOMessageClass: 'createdAt,updatedAt,module+messageClassName',\n        aSocketIOMessage: 'createdAt,updatedAt,messageClassId,messageFilter,sessionId',\n        aSocketIOMessageSync: 'createdAt,updatedAt,messageId,userId,messageRead',\n      },\n    },\n  };\n  return meta;\n};\n","module.exports = app => {\n  const schemas = {};\n  return schemas;\n};\n"],"sourceRoot":""}